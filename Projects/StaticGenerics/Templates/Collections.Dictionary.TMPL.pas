// {{={[ ]}=}}
// !AUTOGENERATED! - {[Prefix]} - !DO NOT EDIT!

unit {[Prefix]};

{ ======================================================================= }
interface
{ ======================================================================= }

uses

  System.SysUtils,

  mormot.core.base,
  mormot.core.data,
  mormot.core.json,
  mormot.core.os,
  mormot.core.rtti,

  Base.Collections.Dictionary;

{ ----------------------------------------------------------------------- }

type

{$REGION 'DEFINE-PARTIAL / interface'}

{[#types]}

  TPair_{[key_flat]}_{[value_flat]} = record
    Key: {[key_type]};
    Value: {[value_type]};
  end;
  
  IPairEnumerator_{[key_flat]}_{[value_flat]} = interface
    ['{[NewGuid]}']
    function GetCurrent: TPair_{[key_flat]}_{[value_flat]};
    function MoveNext: Boolean;
    property Current: TPair_{[key_flat]}_{[value_flat]} read GetCurrent;
  end;

  {[^disable_key_interfaces]}
  IEnumerator_{[key_flat]} = interface
    ['{[NewGuid]}']
    function GetCurrent: {[key_type]};
    function MoveNext: Boolean;
    property Current: {[key_type]} read GetCurrent;
  end;
  {[/disable_key_interfaces]}
  
  {[^disable_value_interfaces]}
  IEnumerator_{[value_flat]} = interface
    ['{[NewGuid]}']
    function GetCurrent: {[value_type]};
    function MoveNext: Boolean;
    property Current: {[value_type]} read GetCurrent;
  end;
  {[/disable_value_interfaces]}
  
  {[^disable_key_interfaces]}
  IEnumerable_{[key_flat]} = interface
    ['{[NewGuid]}']
    function GetEnumerator: IEnumerator_{[key_flat]};
    function ToArray(AOffset: Integer = 0; ACount: Integer = 0): TArray<{[key_type]}>;
  end;
  {[/disable_key_interfaces]}

  {[^disable_value_interfaces]}
  IEnumerable_{[value_flat]} = interface
    ['{[NewGuid]}']
    function GetEnumerator: IEnumerator_{[value_flat]};
    function ToArray(AOffset: Integer = 0; ACount: Integer = 0): TArray<{[value_type]}>;
  end;
  {[/disable_value_interfaces]}
  
  IDictionary_{[key_flat]}_{[value_flat]} = interface(IDictionary)
    ['{[NewGuid]}']
    procedure Add(const AKey: {[key_type]}; const AValue: {[value_type]});
    function  Contains(const AKey: {[key_type]}; const AValue: {[value_type]}): Boolean;
    function  ContainsKey(const AKey: {[key_type]}): Boolean;
    function  Extract(const AKey: {[key_type]}): {[value_type]};
    function  Remove(const AKey: {[key_type]}): Boolean;
    function  GetEnumerator: IPairEnumerator_{[key_flat]}_{[value_flat]};
    function  TryGetValue(const AKey: {[key_type]}; out AValue: {[value_type]}): Boolean;
    function  GetItem(const AKey: {[key_type]}): {[value_type]};    
    function  GetKeyEnumerable: IEnumerable_{[key_flat]};
    {[^disable_value_enumerable]}
    function  GetValueEnumerable: IEnumerable_{[value_flat]};
    {[/disable_value_enumerable]}
    procedure SetItem(const AKey: {[key_type]}; const AValue: {[value_type]});
    property  Keys: IEnumerable_{[key_flat]} read GetKeyEnumerable;
    {[^disable_value_enumerable]}
    property  Values: IEnumerable_{[value_flat]} read GetValueEnumerable;
    {[/disable_value_enumerable]}
    property  Items[const AKey: {[key_type]}]: {[value_type]} read GetItem write SetItem; default;
  end;
{[/types]}

{$ENDREGION 'DEFINE-PARTIAL / interface'}

  {[TCollectionsName]} = class
   public
{$REGION 'DEFINE-PARTIAL / factory-methods-interface'}
{[#types]}
    class function CreateDictionary_{[key_flat]}_{[value_flat]}({[#key_is_object]}AOwnKeys: Boolean; {[/key_is_object]}{[#value_is_object]}AOwnValues: Boolean; {[/value_is_object]}): IDictionary_{[key_flat]}_{[value_flat]}; overload; static; // PostFixParamsDefine
{[/types]}
{$ENDREGION 'DEFINE-PARTIAL / factory-methods-interface'}
  end;

{ ======================================================================= }
implementation
{ ======================================================================= }

{$REGION 'DEFINE-PARTIAL / implementation'}

{[#types]}

type

  CDictionary_{[key_flat]}_{[value_flat]} = class(CDictionaryBase, IDictionary_{[key_flat]}_{[value_flat]})
   strict private type

    CPairEnumerator = class(CDictionaryBase.CEnumerator, IPairEnumerator_{[key_flat]}_{[value_flat]})
     public
      function GetCurrent: TPair_{[key_flat]}_{[value_flat]};
    end;

    CKeyEnumerator = class(CDictionaryBase.CEnumerator, IEnumerator_{[key_flat]})
     public
      function GetCurrent: {[key_type]};
    end;

    {[^disable_value_enumerable]}
    CValueEnumerator = class(CDictionaryBase.CEnumerator, IEnumerator_{[value_flat]})
     public
      function GetCurrent: {[value_type]};
    end;
    {[/disable_value_enumerable]}

    CKeyEnumerable = class(CDictionaryBase.CCollection, IEnumerable_{[key_flat]})
     public
      function GetEnumerator: IEnumerator_{[key_flat]};
      function ToArray(AOffset: Integer = 0; ACount: Integer = 0): TArray<{[key_type]}>;
    end;

    {[^disable_value_enumerable]}
    CValueEnumerable = class(CDictionaryBase.CCollection, IEnumerable_{[value_flat]})
     public
      function GetEnumerator: IEnumerator_{[value_flat]};
      function ToArray(AOffset: Integer = 0; ACount: Integer = 0): TArray<{[value_type]}>;
    end;
    {[/disable_value_enumerable]}

   strict private
    {[#key_is_object]}
    FOwnKeys: Boolean;
    {[/key_is_object]}
    {[#value_is_object]}
    FOwnValues: Boolean;
    {[/value_is_object]}
    function  GetKeyEnumerable: IEnumerable_{[key_flat]};
    {[^disable_value_enumerable]}
    function  GetValueEnumerable: IEnumerable_{[value_flat]};
    {[/disable_value_enumerable]}
    procedure Add(const AKey: {[key_type]}; const AValue: {[value_type]});
    function  Contains(const AKey: {[key_type]}; const AValue: {[value_type]}): Boolean;
    function  ContainsKey(const AKey: {[key_type]}): Boolean;
    function  Extract(const AKey: {[key_type]}): {[value_type]};
    function  Remove(const AKey: {[key_type]}): Boolean;
    function  GetEnumerator: IPairEnumerator_{[key_flat]}_{[value_flat]};
    function  GetItem(const AKey: {[key_type]}): {[value_type]};
    procedure SetItem(const AKey: {[key_type]}; const AValue: {[value_type]});
    function  TryGetValue(const AKey: {[key_type]}; out AValue: {[value_type]}): Boolean;
   public
    constructor Create({[#key_is_object]}AOwnKeys: Boolean; {[/key_is_object]}{[#value_is_object]}AOwnValues: Boolean;{[/value_is_object]}); // PostFixParamsDefine
  end;

{ ======================================================================= }
// CDictionary_{[key_flat]}_{[value_flat]}.CPairEnumerator
{ ======================================================================= }

function CDictionary_{[key_flat]}_{[value_flat]}.CPairEnumerator.GetCurrent: TPair_{[key_flat]}_{[value_flat]};
begin
  Result.Key:={[key_type]}(FSynDict.Keys.ItemPtr(FIndex)^);
  Result.Value:={[value_type]}(FSynDict.Values.ItemPtr(FIndex)^);
end;

{ ======================================================================= }
// CDictionary_{[key_flat]}_{[value_flat]}.CKeyEnumerator
{ ======================================================================= }

function CDictionary_{[key_flat]}_{[value_flat]}.CKeyEnumerator.GetCurrent: {[key_type]};
begin
  Result:={[key_type]}(FSynDict.Keys.ItemPtr(FIndex)^);
end;

{[^disable_value_enumerable]}
{ ======================================================================= }
// CDictionary_{[key_flat]}_{[value_flat]}.CValueEnumerator
{ ======================================================================= }

function CDictionary_{[key_flat]}_{[value_flat]}.CValueEnumerator.GetCurrent: {[value_type]};
begin
  Result:={[value_type]}(FSynDict.Values.ItemPtr(FIndex)^);
end;
{[/disable_value_enumerable]}

{ ======================================================================= }
// CDictionary_{[key_flat]}_{[value_flat]}.CKeyEnumerable
{ ======================================================================= }

function CDictionary_{[key_flat]}_{[value_flat]}.CKeyEnumerable.GetEnumerator: IEnumerator_{[key_flat]};
begin
  Result:=CKeyEnumerator.Create(FSynDict);
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.CKeyEnumerable.ToArray(AOffset, ACount: Integer): TArray<{[key_type]}>;
begin
  FSynDict.Keys.InternalDynArray.SliceAsDynArray(@Result,AOffset,ACount);
end;

{[^disable_value_enumerable]}
{ ======================================================================= }
// CDictionary_{[key_flat]}_{[value_flat]}.CValueEnumerable
{ ======================================================================= }

function CDictionary_{[key_flat]}_{[value_flat]}.CValueEnumerable.GetEnumerator: IEnumerator_{[value_flat]};
begin
  Result:=CValueEnumerator.Create(FSynDict);
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.CValueEnumerable.ToArray(AOffset, ACount: Integer): TArray<{[value_type]}>;
begin
  FSynDict.Values.SliceAsDynArray(@Result,AOffset,ACount);
end;
{[/disable_value_enumerable]}

{ ======================================================================= }
// CDictionary_{[key_flat]}_{[value_flat]}
{ ======================================================================= }

constructor CDictionary_{[key_flat]}_{[value_flat]}.Create({[#key_is_object]}AOwnKeys: Boolean; {[/key_is_object]}{[#value_is_object]}AOwnValues: Boolean; {[/value_is_object]}); // PostFixParamsDefine
begin
  FSynDict:=TSynDictionary.Create(TypeInfo(TArray<{[key_type]}>),TypeInfo(TArray<{[value_type]}>));
  {[#key_is_object]}
  FOwnKeys:=AOwnKeys;
  PDynArray(@FSynDict.Keys.InternalDynArray).NoFinalize:=not FOwnKeys;
  {[/key_is_object]}
  {[#value_is_object]}
  FOwnValues:=AOwnValues;
  PDynArray(@FSynDict.Values).NoFinalize:=not FOwnValues;
  {[/value_is_object]}
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.Contains(const AKey: {[key_type]}; const AValue: {[value_type]}): Boolean;
{[#value_is_method]}
var 
  ArgValuePointer: Pointer absolute AValue;
{[/value_is_method]}
begin
  var ValuePointer: Pointer:=FSynDict.FindValue(AKey);
{[#value_is_method]}
  Result:=Assigned(ValuePointer) and (Pointer(ValuePointer^)=ArgValuePointer);
{[/value_is_method]}
{[^value_is_method]}
  Result:=Assigned(ValuePointer) and ({[value_type]}(ValuePointer^)=AValue);
{[/value_is_method]}
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.ContainsKey(const AKey: {[key_type]}): Boolean;
begin
  Result:=FSynDict.Exists(AKey);
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.Extract(const AKey: {[key_type]}): {[value_type]};
begin
  {[#value_is_object]}
  var ValuesDynArray: PDynArray:=PDynArray(@FSynDict.Values);
  if FOwnValues
    then ValuesDynArray.NoFinalize:=true;
  {[/value_is_object]}
  FSynDict.FindAndExtract(AKey,Result);
  {[#value_is_object]}
  if FOwnValues
    then ValuesDynArray.NoFinalize:=false;
  {[/value_is_object]}
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.Remove(const AKey: {[key_type]}): Boolean;
begin
  Result:=FSynDict.Delete(AKey)>=0;
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.GetEnumerator: IPairEnumerator_{[key_flat]}_{[value_flat]};
begin
  Result:=CPairEnumerator.Create(FSynDict);
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.GetItem(const AKey: {[key_type]}): {[value_type]};
begin
  var ValuePointer: Pointer:=FSynDict.FindValue(AKey);
  if Assigned(ValuePointer)
    then Result:={[value_type]}(ValuePointer^)
    else raise Exception.Create('Key not found');
end;

{ ----------------------------------------------------------------------- }

procedure CDictionary_{[key_flat]}_{[value_flat]}.SetItem(const AKey: {[key_type]}; const AValue: {[value_type]});
begin
  FSynDict.AddOrUpdate(AKey,AValue);
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.GetKeyEnumerable: IEnumerable_{[key_flat]};
begin
  Result:=CKeyEnumerable.Create(FSynDict);
end;

{[^disable_value_enumerable]}
{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.GetValueEnumerable: IEnumerable_{[value_flat]};
begin
  Result:=CValueEnumerable.Create(FSynDict);
end;
{[/disable_value_enumerable]}

{ ----------------------------------------------------------------------- }

procedure CDictionary_{[key_flat]}_{[value_flat]}.Add(const AKey: {[key_type]}; const AValue: {[value_type]});
begin
  FSynDict.Add(AKey,AValue);
end;

{ ----------------------------------------------------------------------- }

function CDictionary_{[key_flat]}_{[value_flat]}.TryGetValue(const AKey: {[key_type]}; out AValue: {[value_type]}): Boolean;
begin
  var ValuePointer: Pointer:=FSynDict.FindValue(AKey);
  if Capture(Assigned(ValuePointer),Result)
    then AValue:={[value_type]}(ValuePointer^);
end;
{[/types]}

{ ======================================================================= }
// {[TCollectionsName]}
{ ======================================================================= }

{[#types]}
class function {[TCollectionsName]}.CreateDictionary_{[key_flat]}_{[value_flat]}({[#key_is_object]}AOwnKeys: Boolean; {[/key_is_object]}{[#value_is_object]}AOwnValues: Boolean;{[/value_is_object]}): IDictionary_{[key_flat]}_{[value_flat]}; // PostFixParamsDefine
begin
  Result:=CDictionary_{[key_flat]}_{[value_flat]}.Create({[#key_is_object]}AOwnKeys,{[/key_is_object]}{[#value_is_object]}AOwnValues,{[/value_is_object]}); // PostFixParamsCall
end;

{ ----------------------------------------------------------------------- }

{[/types]}

{$ENDREGION 'DEFINE-PARTIAL / implementation'}

{ ======================================================================= }
end.