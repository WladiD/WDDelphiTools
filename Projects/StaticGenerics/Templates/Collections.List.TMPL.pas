// {{={[ ]}=}}
// !AUTOGENERATED! - {[Prefix]} - !DO NOT EDIT!

unit {[Prefix]};

interface

uses

  System.SysUtils,

  Base.Collections.List;

type

{$REGION 'DEFINE-PARTIAL / interface'}

{$REGION 'DEFINE-PARTIAL / interface-list'}

{[#types]}
  {$REGION 'DEFINE-PARTIAL / interface-{[type_flat]}'}

  {[> Collections.IEnumerator]}

  {[> Collections.IEnumerable]}

  TPredicate_{[type_flat]} = reference to function(const AValue: {[type]}): Boolean;

  IList_{[type_flat]} = interface(IList)
    ['{[NewGuid]}']
    function  Add(const AItem: {[type]}): Integer;
    procedure AddRange(const AValues: array of {[type]});
    {[#IList.enable_all]}
    function  All(const APredicate: TPredicate_{[type_flat]}): Boolean;
    {[/IList.enable_all]}
    {[#IList.enable_concat]}
    function  Concat(const ASecond: IEnumerable_{[type_flat]}): IList_{[type_flat]};
    {[/IList.enable_concat]}
    function  Contains(const AValue: {[type]}): Boolean;
    {[#IList.enable_distinct]}
    function  Distinct: IEnumerable_{[type_flat]};
    {[/IList.enable_distinct]}
    function  Extract(const AItem: {[type]}): {[type]};
    function  First: {[type]};
    function  FirstOrDefault: {[type]};
    function  GetEnumerator: IEnumerator_{[type_flat]};
    function  GetItem(AIndex: Integer): {[type]};
    function  GetRange(AIndex, ACount: Integer): IList_{[type_flat]};
    function  IndexOf(const AItem: {[type]}): Integer;
    procedure Insert(AIndex: Integer; const AItem: {[type]});
    function  Last: {[type]};
    function  LastOrDefault: {[type]};
    function  Remove(const AItem: {[type]}): Boolean;
    {[#IList.enable_remove_all]}
    function  RemoveAll(const APredicate: TPredicate_{[type_flat]}): Integer;
    {[/IList.enable_remove_all]}
    procedure SetItem(AIndex: Integer; const AValue: {[type]});
    function  ToArray(AOffset: Integer = 0; ACount: Integer = 0): TArray<{[type]}>;
    {[#IList.enable_where]}
    function  Where(const APredicate: TPredicate_{[type_flat]}): IEnumerable_{[type_flat]};
    {[/IList.enable_where]}
    property  Items[AIndex: Integer]: {[type]} read GetItem write SetItem; default;
  end;

  {$ENDREGION 'DEFINE-PARTIAL / interface-{[type_flat]}'}
{[/types]}

{$ENDREGION 'DEFINE-PARTIAL / interface-list'}

{$ENDREGION 'DEFINE-PARTIAL / interface'}

  {[TCollectionsName]} = class
   public
{$REGION 'DEFINE-PARTIAL / factory-methods-interface'}
{[#types]}

  {[^type_is_object]}  
    class function CreateList_{[type_flat]}: IList_{[type_flat]}; overload; static;
    class function CreateList_{[type_flat]}(const ACopyFrom: IEnumerable_{[type_flat]}): IList_{[type_flat]}; overload; static;
    {[#factory.enable_create_copy_from_array]}
    class function CreateList_{[type_flat]}(const ACopyFrom: array of String): IList_{[type_flat]}; overload; static;
    {[/factory.enable_create_copy_from_array]}
    {[#factory.enable_create_unique]}
    class function CreateListUnique_{[type_flat]}: IList_{[type_flat]}; overload; static;
    {[/factory.enable_create_unique]}
  {[/type_is_object]}

  {[#type_is_object]}
    class function CreateList_{[type_flat]}(AOwnsObjects: Boolean): IList_{[type_flat]}; overload; static;
    class function CreateList_{[type_flat]}(const ACopyFrom: IEnumerable_{[type_flat]}; AOwnsObjects: Boolean): IList_{[type_flat]}; overload; static;
  {[/type_is_object]}
{[/types]}

{$ENDREGION 'DEFINE-PARTIAL / factory-methods-interface'}
  end;

implementation

{$REGION 'DEFINE-PARTIAL / implementation'}

{[#types]}{[^type_is_object]}

type

  CListEnumerator_{[type_flat]} = class(CListEnumeratorBase, IEnumerator_{[type_flat]})
   strict protected
    function GetCurrent: {[type]};
  end;

  CList_{[type_flat]} = class({[clist_unit]}CList, IList_{[type_flat]}, IEnumerable_{[type_flat]})
   protected
    function  Add(const AItem: {[type]}): Integer;
    procedure AddRange(const AValues: array of {[type]});
    {[#IList.enable_all]}
    function  All(const APredicate: TPredicate_{[type_flat]}): Boolean;
    {[/IList.enable_all]}
    {[#IList.enable_concat]}
    function  Concat(const ASecond: IEnumerable_{[type_flat]}): IList_{[type_flat]};
    {[/IList.enable_concat]}
    function  Contains(const AValue: {[type]}): Boolean;
    {[#IList.enable_distinct]}
    function  Distinct: IEnumerable_{[type_flat]};
    {[/IList.enable_distinct]}
    function  Extract(const AItem: {[type]}): {[type]};
    function  First: {[type]};
    function  FirstOrDefault: {[type]};
    function  GetEnumerator: IEnumerator_{[type_flat]};
    function  GetItem(AIndex: Integer): {[type]};
    function  GetRange(AIndex, ACount: Integer): IList_{[type_flat]};
    function  IndexOf(const AItem: {[type]}): Integer;
    procedure Insert(AIndex: Integer; const AItem: {[type]});
    function  Last: {[type]};
    function  LastOrDefault: {[type]};
    function  Remove(const AItem: {[type]}): Boolean;
    {[#IList.enable_remove_all]}
    function  RemoveAll(const APredicate: TPredicate_{[type_flat]}): Integer;
    {[/IList.enable_remove_all]}
    procedure SetItem(AIndex: Integer; const AValue: {[type]});
    function  ToArray(AOffset, ACount: Integer): TArray<{[type]}>;
    {[#IList.enable_where]}
    function  Where(const APredicate: TPredicate_{[type_flat]}): IEnumerable_{[type_flat]};
    {[/IList.enable_where]}
  end;

{ CListEnumerator_{[type_flat]} }

function CListEnumerator_{[type_flat]}.GetCurrent: {[type]};
begin
  Result:=CList_{[type_flat]}(FList).GetItem(FIndex);
end;

{ CList_{[type_flat]} }

{[#IList.enable_concat]}
function CList_{[type_flat]}.Concat(const ASecond: IEnumerable_{[type_flat]}): IList_{[type_flat]};
begin
  Result:={[TCollectionsName]}.CreateList_{[type_flat]}(Self);
  for var Item in ASecond 
    do Result.Add(Item);
end;

{[/IList.enable_concat]}

function CList_{[type_flat]}.Add(const AItem: {[type]}): Integer;
var
  Added: boolean;
begin
  Result:=DoAdd(AItem,Added);
  if Added
    then TArray<{[type]}>(fValue)[Result]:=AItem;
end;

procedure CList_{[type_flat]}.AddRange(const AValues: array of {[type]});
begin
  for var Value in AValues
    do Add(Value);
end;

{[#IList.enable_all]}
function CList_{[type_flat]}.All(const APredicate: TPredicate_{[type_flat]}): Boolean;
begin
  for var Loop:=0 to GetCount-1 do
  begin
    if not APredicate(GetItem(Loop)) 
      then Exit(false);
  end;
  Result:=true;
end;

{[/IList.enable_all]}

function CList_{[type_flat]}.Contains(const AValue: {[type]}): Boolean;
begin
  Result:=IndexOf(AValue)>=0;
end;
{[#IList.enable_distinct]}

function CList_{[type_flat]}.Distinct: IEnumerable_{[type_flat]};
begin
  var DistinctList:=FList.Distinct;
  var ResultList:=TBaseCollections.CreateList_{[type_flat]}(DistinctList.ToArray);
  Result:=ResultList as IEnumerable_{[type_flat]};
end;
{[/IList.enable_distinct]}

function CList_{[type_flat]}.Extract(const AItem: {[type]}): {[type]};
begin
  Result:={[type]}(Extract(AItem));
end;

function CList_{[type_flat]}.First: {[type]};
begin
  Result:=GetItem(0);
end;

function CList_{[type_flat]}.FirstOrDefault: {[type]};
begin
  if IsEmpty
    then Result:=Default({[type]})
    else Result:=GetItem(0);
end;

function CList_{[type_flat]}.GetEnumerator: IEnumerator_{[type_flat]};
begin
  Result:=CListEnumerator_{[type_flat]}.Create(Self);
end;

function CList_{[type_flat]}.GetItem(AIndex: Integer): {[type]};
begin
  if AIndex>=fCount then
    RaiseGetItem(AIndex);
  Result:=TArray<{[type]}>(fValue)[AIndex];
end;

function CList_{[type_flat]}.GetRange(AIndex, ACount: Integer): IList_{[type_flat]};
begin
  Result:={[TCollectionsName]}.CreateList_{[type_flat]}(GetRange(AIndex,ACount) as IEnumerable_{[type_flat]});
end;

function CList_{[type_flat]}.IndexOf(const AItem: {[type]}): Integer;
begin
  Result:=DoFind(AItem,nil);
end;

procedure CList_{[type_flat]}.Insert(AIndex: Integer; const AItem: {[type]});
begin
  DoInsert(AIndex,AItem);
end;

function CList_{[type_flat]}.Last: {[type]};
begin
  Result:=GetItem(GetCount-1);
end;

function CList_{[type_flat]}.LastOrDefault: {[type]};
begin
  if IsEmpty
    then Result:=Default({[type]})
    else Result:=GetItem(Count-1);
end;

function CList_{[type_flat]}.Remove(const AItem: {[type]}): Boolean;
begin
  Result:=DoRemove(AItem);
end;

{[#IList.enable_remove_all]}
function CList_{[type_flat]}.RemoveAll(const APredicate: TPredicate_{[type_flat]}): Integer;
begin
  Result:=0;
  for var Loop:=GetCount-1 downto 0 do
  begin
    if APredicate(GetItem(Loop)) then
    begin
      Delete(Loop);
      Inc(Result);
    end;
  end;
end;
{[/IList.enable_remove_all]}

procedure CList_{[type_flat]}.SetItem(AIndex: Integer; const AValue: {[type]});
begin
  if Assigned(fHasher) or (AIndex>=fCount)
    then RaiseSetItem(AIndex);
  TArray<{[type]}>(fValue)[AIndex]:=AValue;
end;

function CList_{[type_flat]}.ToArray(AOffset, ACount: Integer): TArray<{[type]}>;
begin
  fDynArray.SliceAsDynArray(@Result,AOffset,ACount);
end;

{[#IList.enable_where]}

function CList_{[type_flat]}.Where(const APredicate: TPredicate_{[type_flat]}): IEnumerable_{[type_flat]};
var
  ResultList: CList_{[type_flat]};
begin
  ResultList:=CList_{[type_flat]}.Create;
  for var Loop:=0 to GetCount-1 do
  begin
    var Item:=GetItem(Loop);
    if APredicate(Item) 
      then ResultList.Add(Item);
  end;
  if ResultList.Any 
    then Result:=ResultList as IEnumerable_{[type_flat]};  
end;
{[/IList.enable_where]}

{[/type_is_object]}{[/types]}

{ {[TCollectionsName]} }

{[#types]}{[#type_is_object]}
class function {[TCollectionsName]}.CreateList_{[type_flat]}(AOwnsObjects: Boolean): IList_{[type_flat]};
begin
  var TempList: IList_TObject:=CObjectList.Create(AOwnsObjects,IList_{[type_flat]},IEnumerable_{[type_flat]});
  Result:=IList_{[type_flat]}(TempList);
end;

class function {[TCollectionsName]}.CreateList_{[type_flat]}(const ACopyFrom: IEnumerable_{[type_flat]}; AOwnsObjects: Boolean): IList_{[type_flat]};
begin
  Result:=CreateList_{[type_flat]}(AOwnsObjects);
  for var AItem in ACopyFrom
    do Result.Add(AItem);
end;

{[/type_is_object]}{[/types]}

{[#types]}{[^type_is_object]}
class function {[TCollectionsName]}.CreateList_{[type_flat]}: IList_{[type_flat]};
begin
  Result:=CList_{[type_flat]}.Create(TypeInfo(TArray<{[type]}>),TypeInfo({[type]}));
end;

{[#factory.enable_create_unique]}

class function {[TCollectionsName]}.CreateListUnique_{[type_flat]}: IList_{[type_flat]};
begin
  Result:=CList_{[type_flat]}.Create(TypeInfo(TArray<{[type]}>),TypeInfo({[type]}),[loCreateUniqueIndex]);
end;

{[/factory.enable_create_unique]}

class function {[TCollectionsName]}.CreateList_{[type_flat]}(const ACopyFrom: IEnumerable_{[type_flat]}): IList_{[type_flat]};
begin
  Result:=CreateList_{[type_flat]};
  for var AItem in ACopyFrom
    do Result.Add(AItem);
end;

{[#factory.enable_create_copy_from_array]}

class function {[TCollectionsName]}.CreateList_{[type_flat]}(const ACopyFrom: array of String): IList_{[type_flat]};
begin
  Result:=CreateList_{[type_flat]};
  for var AItem in ACopyFrom
    do Result.Add(AItem);
end;
{[/factory.enable_create_copy_from_array]}

{[/type_is_object]}{[/types]}

{$ENDREGION 'DEFINE-PARTIAL / implementation'}

end.
